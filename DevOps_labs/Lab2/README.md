<h1 align="center">Лабораторная работа 2</h1>

### Цель работы
Написать два Dockerfile – плохой и хороший. Плохой должен запускаться и работать корректно, но в нём должно быть не менее 3 “bad practices”.
В хорошем Dockerfile они должны быть исправлены. Также привести 2 плохие практики по использованию хорошего контейнера.

### Предисловие
Было решено контейнеризировать веб-приложение, созданное с помощью Django Framework.
В качестве HTTP-сервера для нашего приложения был выбран Gunicorn.

### Плохие практики
* #### [Избыточность](#12)

  Использование образа ubuntu, вместо более подходящего для нашей цели образа python.
* #### [Использование `:latest` версий](#12)

  Нарушает неизменность контейнера, так как обновление образа может привести к ошибке.
* #### [Копирование всех файлов одной командой](#3)

  Может плохо сказаться на производительности контейнера. 
* #### [Миграции во время билда](#12)
  Может привести к ошибкам, если база данных
  будет не доступна во время сборки или если
  надо использовать тот же образ с другой бд.

## Глава 1. Плохой Докер.

### Часть 1. Подготовка Django-проекта
Для начала создадим папку с пустым Dockerfile-ом и файлом         `requirements.txt`, в который запишем требуемые для установки библиотеки Python.

![Создание файла requirements.txt](./images/requirements.png)

Далее создаём виртуальное окружение Python и активируем его. С помощью команды `django-admin startproject -v 3 Docker .` создаём приложение Django с именем Docker.

![Создание приложения Django](./images/make-django-project(2).png)

Создаём файл .dockerignore, в который добавляем:
* db.sqlite — база данных проекта. 
* venv — папка с виртуальным окружением
* \_\_pycache\_\_ — папка с байткодом python модулей/приложений


![Создание .dockerignore](./images/dockerignore(3).png)

### Часть 2. Работа с Docker
Пишем инструкции в Dockerfile.
<a name="12">Подключаем образ `ubuntu:latest`</a> *(bad practice #1, #2)*

Устанавливаем `python3` и `pip`.

<a name="3">Копируем файлы из нашей директории в контейнер.</a> *(bad practice #3)*

С помощью `pip` устанавливаем библиотеки из файла 'requirements.txt'

Производим миграции в БД. *(bad practice #4)*

С помощью команды `CMD`, которая вызывается в начале работы контейнера, поднимаем сервер gunicorn.
Открываем порт 8000 командой `EXPOSE 8000`.

[Заполнение Dockerfile](./images/Dockerfile(4).png)

Билдим наш Dockerfile в образ "django".

![Build Dockerfile](./images/docker-build(5).png)

Поднимаем контейнер командой `docker run`, при этом с помощью параметра `p` открываем порт 8000.

![Run Dockerfile](./images/docker-run(7).png)

На хосте переходим по 127.0.0.1:8000 и видим поднятый сервер.


![Результат](./images/django-successful(10).png)


## Глава 2. Хороший Докер.

### Правильный выбор образа

Первым делом выберем подходящий образ.
Логично, что для запуска Django приложения 
стоит выбрать образ Django. Однако, если 
зайдем на страницу официального образа Django
на Docker Hub то увидим, что образ отмечен как
Вместо него рекомендуется использовать Python. Его мы
и выберем.

![Django на Docker Hub](./images/django_docker_hub.png)

Был выбран образ 3.11.5-bookworm, так как версия 3.11.5
использовалась при разработке проекта. Приставка bookworm
означает кодовое имя релиза Debian, на основе которого
был создан image. Версии slim и alpine рекомендуется
использовать в случае ограниченности места, поэтому
нам нет смысла их ставить. 
Для использования данного образа в Dockerfile
заменим строчку `FROM ubuntu:latest` на `FROM python:3.11.5-bookworm`
Таким образом мы подобрали image, который лучше подходит
под наши цели. Так же были указав точную версию
(а не тег latest) мы избавились от возможных проблем
из-за более новой версии образа.

### Ускоряем сборку контейнера

В докере используется система кэша, которая позволяет
ускорить сборку. Каждая инструкция внутри 
Dockerfile преобразуется в слой в конечном образе. 
Кэширование позволяет не пересобирать верхние слои, 
которые не были подвергнуты изменениям. Ниже приведена
иллюстрация принципа работы с официального сайта Docker.

![демонстрация слоев в Docker](./images/docker-layers.png)

В случае нашего Dockerfile преимущества описанной системы
можно использовать при копировании проекта
и установке зависимостей. Если мы сначала будем
копировать в контейнер файл зависимостей и устанавливать их, 
а только потом копировать весь проект, то при изменении файлов
проекта не надо будет заново ставить необходимые модули.

В итоге команды 
![!Без оптимизации](./images/no_cache_optimisation.png)
Были заменены на 
![С оптимизацией](./images/with_optimisation.png)

### Убираем миграции

Как уже говорилось выше, миграции во время сборки 
могут привести к ошибкам, если база данных в этот момент 
не доступна или мы хотим использовать другую БД (например
тестовую). Дабы избежать этой проблемы можно выполнить
миграции после запуска контейнера через команду
`docker exec -it <container_id> python manage.py migrate`

### Конечный результат

Исправленный Dockerfile можно увидеть ниже

![Исправленный Dockerfile](./images/good_dockerfile.png)

Проверим, всё ли работает как раньше.\
Для начала соберем образ командой\
`sudo docker buildx build -t good_dockerfile .`
![сборка](./images/build_good_dockerfile.png)
Теперь запустим контейнер командой\
`sudo docker run -p 8000:80 good_dockerfile`\
![Запуск контейнера](./images/start_good_dockerfile.png)
На хост-машине открываем 127.0.0.1:8000 и видим поднятый
сервер.
![работающий сервер](./images/good_server.png)

## Плохие практики по использованию этого контейнера

### Использование в качестве виртуальной машины

Важно понимать различие в работе и предназначении виртуальных
машин и контейнеров. Это неэффективно и небезопасно. 
Данные технологии создавались для достижения различных целей. 


### Хранение секретов внутри этого контейнера

Не стоит хранить секреты внутри контейнера. Для этого есть
более безопасные способы хранения.

## Итоги

В ходе работы мы смогли написать два Dockerfile, в
одном из которых мы показали плохие практики. При этом
оба Dockerfile успешно запускались и функционировали.
